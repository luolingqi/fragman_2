/***********************************************************************

  dimer.c - Program to identifying the interacting residues (hydrogen
            bonded and non-bonded contacts) across the interface of a dimer
            (or between two domains). The residues and interaction data are
            read by LIGPLOT to produce a graphical plot of the interactions
            across the interface.

************************************************************************

Version:-      v.1.0  -  28 September 1997

Written by:-   Alice Wuensche & Roman Laskowski

               Department of Crystallography
               Birkbeck College
               Malet Street, London WC1E 7HX, UK.

Requirements:- An input PDB file and corresponding .hhb and .nnb files
               generated by HBPLUS. If interactions across a domain
               interface are to be plotted, then a .dom file defining the
               domains is also required.

------------------------------------------------------------------------

Program description
-------------------

Program reads in the given PDB file and corresponding .hhb and .nnb files.
It identifies all interacting residues either from two user-defined chains,
or from two domains. Domain definitions have to be supplied in a .dom file.
The program's outputs are three files: hblinks.pdb, .hhb and .nnb, being
extractions from the original files but containing only the residues and 
their interactions across the given interface.

-------------------------------------------------------------------------
 
Original version was part of v.4.0 of LIGPLOT. Subsequent amendments
have been labelled by v.m.n--> and <--v.m.n where m.n is the
version number corresponding to the change.

-------------------------------------------------------------------------

Function calling-tree
---------------------
 
main
   -> get_command_arguments
   -> get_filename
   -> get_domains
         -> get_domain_number
         -> get_residue_range
               -> get_token
               -> format_number
   -> read_pdb
         -> check_residue
   -> read_hbplus_file
         ->get_hbplus_info
   -> check_waters
   -> output_hbplus_info
   -> pdb_out

-------------------------------------------------------------------------*/

/* Header file */
#include "dimer.h"

/***********************************************************************

get_command_arguments  -  Get the name of the input PDB file and options
                          from the command line

***********************************************************************/

void get_command_arguments(char *argv[],int argc,char pdb_name[FILENAME_LEN],
			   char *chain1,char *chain2,int *by_domain,
			   int *domain1,int *domain2)
{
  int input_error;
  int namlen;

  /* Initialise variables */
  *by_domain = FALSE;

  /* Check that input arguments look OK */
  input_error = FALSE;
  /* Three arguments suggests PDB filename plus two chains */
  if (argc == 3)
    {
      /* Check for error */
      if ((int) strlen(argv[2]) != 1 && (int) strlen(argv[3]) != 1)
	input_error = TRUE;

      /* If looks OK, then store chains */
      else
	{
	  /* Store the two chains */
	  *chain1 = argv[2][0];
	  *chain2 = argv[3][0];
	}
    }

  /* Four arguments suggests PDB filename plus two domains, so second
     argument should be -d */
  else if (argc == 4)
    {
      /* Check that second argument is a -d */
      if (strncmp(argv[2],"-d",2))
	input_error = TRUE;

      /* If looks OK, then store domains */
      else
	{
	  /* Extract and store the domains */
	  *by_domain = TRUE;
	  *domain1 = atoi(argv[3]);
	  *domain2 = atoi(argv[4]);

	  /* Check that domain numbers not equal */
	  if (*domain1 == *domain2)
	    input_error = TRUE;
	}
    }
  else
    input_error = TRUE;

  /* If incorrect number of command-line arguments entered, then report
     error */
  if (input_error == TRUE)
    {
      printf("\n");
      printf("*** ERROR. Correct usage is:\n");
      printf("\n");
      printf("    dimer  pdb_filename  chain1  chain2\n");
      printf("OR\n");
      printf("    dimer  pdb_filename  -d  domain1  domain2\n");
      printf("\n");
      printf("where\n");
      printf("    pdb_filename      = PDB file to be processed\n");
      printf("    chain1 & chain2   = single letter names of the");
      printf(" chains to be analysed\n");
      printf("    -d                = signifies that interface across two");
      printf(" domains required\n");
      printf("    domain1 & domain2 = integers corresponding to the two");
      printf(" domains, as defined\n");
      printf("                        in the .dom file\n");
      printf("\n");
      printf("For example:-\n");
      printf("\n");
      printf("    dimer  p2msb.pdb  A  B\n");
      printf("OR\n");
      printf("    dimer  p1art.pdb  -d  1  2\n");
      exit(1);
    }
 
  /* Check that length of filename not too long */
  namlen = strlen(argv[1]);
  if (namlen > FILENAME_LEN - 1)
    {
      printf("\n");
      printf("*** ERROR. Length of PDB filename longer than %d characters\n",
             FILENAME_LEN);
      printf("***        [%s]\n",argv[1]);
      printf("***        Program dimer terminated with error.\n");
      printf("\n");
      exit(1);
    }

  /* Store the PDB filename */
  strcpy(pdb_name,argv[1]);
}


/***********************************************************************

getnam  -  Peel off the directory path and extension from the full name
           of the .pdb file

***********************************************************************/

int getnam(char pdbfil[FILENAME_LEN],int *istart,int *iend)
{
    char pchar;
    int  finish, gotdot, ipos, istate;


    /* Initialise variables */
    finish = FALSE;
    *iend = -1;
    *istart = 0;
    istate = 1;
    ipos = strlen(pdbfil) - 1;
    gotdot = FALSE;

    /* Check through the filename from right to left */
    while (finish == FALSE && ipos > -1)
    {

        /* Pick off next character */
        pchar = pdbfil[ipos];


        /* State 1: Searching for first non-blank character */
        if (istate == 1)
        {
            if (pchar == '/' || pchar == '\\' || pchar == ']')
            {
                printf("*** ERROR in supplied name of file: [%s\n",
                       pdbfil);
                return(-1);
            }

            if (pchar != ' ' && pchar != '.')
            {
                *iend = ipos;
                istate = 2;
            }
        }

        /* State 2: Searching for end of extension, or end of
           directory path */
        else if (istate == 2)
        {
            /* If character is a dot, and is the first dot, then
               note position */
            if (pchar == '.' && gotdot == FALSE)
            {
                *iend = ipos - 1;
                gotdot = TRUE;
            }

            /* If character signifies the end of a directory path,
               note pstn */
            else if (pchar == '/' || pchar == '\\' || pchar == ']')
            {
                *istart = ipos + 1;
                finish = TRUE;
            }
        }

        /* Step back a character */
        ipos = ipos - 1;
    }

    /* Check whether file name is sensible */
    if (*istart > *iend)
    {
        printf("*** ERROR in supplied name of file: %s\n", pdbfil);
        printf("    No name found\n");
        return(-1);
    }
    return(0);
}


/***********************************************************************

get_filename  -  Strip off directory path of PDB filename
                 and append required extention to root

***********************************************************************/

void get_filename(char pdb_name[FILENAME_LEN], char file_name[FILENAME_LEN],
                  char extension[10],char root_name[FILENAME_LEN],
		  char full_root_name[FILENAME_LEN])
{
    int iend, ierror, inew, ipos, istart;

    /* Initialise returned filename */
    file_name[0] = '\0';
    root_name[0] = '\0';
    full_root_name[0] = '\0';

    /* Check that PDB filename is valid */
    if (pdb_name[0] != '\0' && pdb_name[0] != '\n')
    {
        /* Peel off the directory path and extension, returning just
           the root file name */
        ierror = getnam(pdb_name,&istart,&iend);
        if (ierror != -1)
        {
            /* Transfer just the root name into new file name */
            for (ipos = istart, inew = 0; ipos < iend + 1;
                 ipos++, inew++)
                file_name[inew] = pdb_name[ipos];
            file_name[inew] = '\0';

            /* Repeat for the full root name */
            for (ipos = 0; ipos < iend + 1; ipos++)
                full_root_name[ipos] = pdb_name[ipos];
            file_name[iend + 1] = '\0';

            /* Store the root name */
            strcpy(root_name,file_name);

            /* Append the extension */
            strcat(file_name,extension);
        }
    }
}
/***********************************************************************

get_domain_number - Get the domain number from the current line

**********************************************************************/	 

int get_domain_number(char line[LINE_LEN +1],int *ipos)
{
  char ch, number_string[NUMBER_LEN + 1];

  int domain, i;
  int done;

  /* Initialise domain number */
  domain = -1;
  done = FALSE;
  i = 0;

  /* Loop until domain number found */
  while (done == FALSE && *ipos < LINE_LEN)
    {
      /* Get the next character in the string */
      ch = line[*ipos];

      /* If have a number, then add it to the number-string */
      if (ch >= '0' && ch <= '9')
	{
	  /* Add to number-string provided not too long */
	  if (i < NUMBER_LEN)
	    {
	      number_string[i] = ch;
	      i++;
	    }
	}

      /* Otherwise, take this to be the end of the domain-number */
      else if (i > 0)
	{
	  /* Extract the domain number */
	  number_string[i] = '\0';
	  domain = atoi(number_string);
	  done = TRUE;
	}

      /* Go to the next character in the line */
      (*ipos)++;
    }

  /* Return the domain number */
  return(domain);
} 
/***********************************************************************

get_token - Get the domain number from the current line

**********************************************************************/	 

int get_token(char line[LINE_LEN +1],int *ipos,char token[TOKEN_LEN + 1],
	      int *done)
{
  char ch;

  int i;
  int have_token;

  /* Initialise variables */
  *done = FALSE;
  have_token = FALSE;
  i = 0;
  token[0] = '\0';

  /* Loop until domain number found */
  while (*done == FALSE && have_token == FALSE && *ipos < LINE_LEN)
    {
      /* Get the next character in the string */
      ch = line[*ipos];

      /* Check for end of line */
      if (ch == '\0' || ch == '\n')
	*done = TRUE;

      /* If have a space, then take to be the end of the token if have
	 already got something in it */
      else if (ch == ' ')
	{
	  /* If have a token, then we are done */
	  if (token[0] != '\0')
	    have_token = TRUE;
	}

      /* Otherwise, add character to token-string provided not too long */
      else
	{
	  if (i < TOKEN_LEN)
	    {
	      token[i] = ch;
	      i++;
	    }
	}

      /* Go to the next character in the line */
      (*ipos)++;
    }

  /* Terminate the token-string */
  token[i] = '\0';
  if (i > 0)
    {
      have_token = TRUE;
      *done = FALSE;
    }

  /* Return the domain number */
  return(have_token);
} 
/***********************************************************************

format_number - Right-justify residue number, taking into account whether
                it includes an insertion code

**********************************************************************/	 

void format_number(char residue_number[6],char token[TOKEN_LEN + 1])
{
  char ch;

  int ipos, len, start_pos;

  /* Initialise variables */
  strncpy(residue_number,"     ",5);
  residue_number[5] = '\0';

  /* Get length of token-string */
  len = strlen(token);

  /* Proceed if have a token to process */
  if (len > 0)
    {
      /* If token is maximum length, then transfer as is */
      if (len >= 5)
	{
	  /* Set start-position at start of token */
	  start_pos = 0;
	  len = 5;
	}

      /* Otherwise, determine how number is to be transferred */
      else
	{
	  /* Check whether last character is a number or an insertion code */
	  ch = token[len - 1];

	  /* If it is a number, then add a space onto the end */
	  if (ch >= '0' && ch <= '9')
	    {
	      token[len] = ' ';
	      token[len + 1] = '\0';
	      len++;
	    }

	  /* Calculate start-position for transfer */
	  start_pos = 5 - len;
	}

      /* Perform the transfer of the residue number to justify it as
	 required */
      for (ipos = 0; ipos < len; ipos++)
	residue_number[start_pos + ipos] = token[ipos];
      residue_number[5] = '\0';
    }
} 
/***********************************************************************

get_residue_range - Get the next residue range from the current line

**********************************************************************/	 

int get_residue_range(char line[LINE_LEN +1],int *ipos,
		      char start_residue[6],char end_residue[6],char *chain,
		      int *end)
{
  char residue_number[6], token[TOKEN_LEN + 1];

  int ipstn;
  int done, have_range, have_token;

  /* Initialise chain-id */
  *chain = ' ';
  *end = FALSE;
  start_residue[0] = '\0';
  end_residue[0] = '\0';
  done = FALSE;
  have_range = FALSE;
  ipstn = *ipos;

  /* Loop until domain number found */
  while (have_range == FALSE && done == FALSE && *ipos < LINE_LEN)
    {
      /* Get the next token from the line */
      have_token = get_token(line,&ipstn,token,&done);

      /* If have a valid token, then extract appropriate part of range */
      if (have_token == TRUE)
	{
	  /* Check that haven't found a range separator */
	  if (!strncmp(token,"&",1))
	    have_range = TRUE;

	  /* Otherwise, store appropriate part of range */
	  else if (strncmp(token,"-",1))
	    {
	      /* If don't have a start of range, then take this to be it */
	      if (start_residue[0] == '\0')
		{
		  /* Format the residue number and store */
		  format_number(residue_number,token);
		  strcpy(start_residue,residue_number);
		}

	      /* If don't have an end of range, then take this to be it */
	      else if (end_residue[0] == '\0')
		{
		  /* Format the residue number and store */
		  format_number(residue_number,token);
		  strcpy(end_residue,residue_number);
		}

	      /* Otherwise, take this to be the chain-id */
	      else
		*chain = token[0];
	    }
	}
    }

  /* Check whether have a range */
  if (start_residue[0] != '\0' && end_residue[0] != '\0')
    have_range = TRUE;

  /* Return current position in the line */
  *ipos = ipstn;
  *end = done;

  /* Return the done flag */
  return(have_range);
} 
/***********************************************************************

get_domains - Read in the domain definitions from the .dom file

**********************************************************************/	 

void get_domains(char dom_name[FILENAME_LEN],
		 char full_dom_name[FILENAME_LEN],int domain1,int domain2)
{
  char line[LINE_LEN +1];
  char chain, start_residue[6], end_residue[6];

  int domain, ipos;
  int done, have_domain1, have_domain2, have_file, have_range;
 
  struct domain *domain_ptr;

  FILE *fil_dom;

  /* Initialise variables */
  first_domain_ptr = NULL;         
  last_domain_ptr = NULL;
  have_domain1 = FALSE;
  have_domain2 = FALSE;
  have_file = FALSE;

  /* Open the .dom domains file in the current working directory */
  printf("\n");
  if ((fil_dom = fopen(dom_name,"r")) == NULL)
    {
      /* Domain file not present in the current directory, so look for
	 it in the same directory as the PDB file */

      if ((fil_dom = fopen(full_dom_name,"r")) == NULL)
	{
	  printf("\n*** Unable to open your .dom domain file\n",dom_name);
	  printf("\n*** File [%s] not found\n",dom_name);
	  printf("\n*** File [%s] not found\n",full_dom_name);
	  exit(1);
	}
      else
	printf("Opened .dom file [%s] ...",full_dom_name);
    }
  else
    printf("Opened .dom file [%s] ...",dom_name);

  /* Prepare to start reading in the data from the DOM file */
  printf("\n");
  printf("  Reading through .dom file ...\n\n");

  /* Loop while reading in the domain data */
  while (fgets(line,LINE_LEN,fil_dom) !=NULL)      
    { 
      /* Check if valid record */ 
      if (!strncmp(line,"DOMAIN",6) || !strncmp(line,"Domain",6) ||
	  !strncmp(line,"domain",6))
        {
	  /* Get the domain number */
	  ipos = 6;
	  domain = get_domain_number(line,&ipos);

	  /* Initialise flag */
	  done = FALSE;

	  /* Check whether this is one of the domains required */
	  if (domain == domain1)
	    have_domain1 = TRUE;
	  else if (domain == domain2)
	    have_domain2 = TRUE;
	  else
	    done = TRUE;

	  /* If have a valid domain number, then extract all the residue
	     details */
	  while (done == FALSE && domain > -1)
	    {
	      /* Get the next residue-range in the current line */
	      have_range = get_residue_range(line,&ipos,start_residue,
					     end_residue,&chain,&done);

	      /* If have a residue-range, then store */
	      if (have_range == TRUE)
		{
		  /* Allocate memory to store this domain's details */  
		  domain_ptr=(struct domain*)malloc(sizeof(struct domain));
		  if (domain_ptr == NULL)
		    {
		      printf("*** Can't allocate memory for struct");
		      printf(" domain\n");
		      exit (1);
		    }

		  /* If this is first domain record stored, then
		     update pointer to head of linked list */
		  if (first_domain_ptr == NULL)
		    first_domain_ptr = domain_ptr;

		  /* Otherwise update previous domain's link so it points to
		     this one*/
		  else
		    last_domain_ptr->next_domain_ptr = domain_ptr;

		  /* Store details from record read in */
		  domain_ptr->domain_number = domain;
		  domain_ptr->chain = chain;
		  strncpy(domain_ptr->start_residue_number,start_residue,5);
		  domain_ptr->start_residue_number[5] = '\0';
		  strncpy(domain_ptr->end_residue_number,end_residue,5);
		  domain_ptr->end_residue_number[5] = '\0';

		  /* Set next domain pointer to null */
		  domain_ptr->next_domain_ptr = NULL;

		  /* Save current domain's pointer as last domain pointer */
		  last_domain_ptr = domain_ptr;
		}
	    }
	}
    }

  /* close dom file */
  fclose(fil_dom);

  /* Check whether have definitions for both domains */
  if (have_domain1 == FALSE || have_domain2 == FALSE)
    {
      /* Print error message if first domain undefined */
      if (have_domain1 == FALSE)
	printf("*** Error. Domain number %d undefined in .dom file\n",
	       domain1);

      /* Print error message if second domain undefined */
      if (have_domain2 == FALSE)
	printf("*** Error. Domain number %d undefined in .dom file\n",
	       domain2);

      /* Terminate the program */
      printf("***        Program aborted\n");     
      exit(1);
    }
}  
/***********************************************************************

check_residue - Check whether residue belongs to one of the required
                chains/domains

**********************************************************************/	 

int check_residue(char res_num[6],char chain,char chain1,char chain2,
		   int by_domain,int domain1)
{
  int chain_domain;
  int over_start, under_end;

  struct domain *domain_ptr;

  /* Initialise varibale showing to which chain/domain residue belongs */
  chain_domain = 0;

  /* If sekection is by chain, check whether this residue belongs to
     either of the chains */
  if (by_domain == FALSE)
    {
      if (chain == chain1)
	chain_domain = 1;
      else if (chain == chain2)
	chain_domain = 2;
    }

  /* Otherwise, determine whether the residue belongs to one of the given
     residue ranges */
  else
    {
      /* Initialise pointer to the first of the domain records */
      domain_ptr = first_domain_ptr;

      /* Loop through all the domain records */
      while (domain_ptr != NULL && chain_domain == 0)
	{
	  /* Check whether the chain-id is right */
	  if (chain == domain_ptr->chain)
	    {
	      /* Check whether the residue number falls within the current
		 residue range */
	      if (strncmp(res_num,domain_ptr->start_residue_number,5) >= 0)
		over_start = TRUE;
	      else
		over_start = FALSE;
	      if (strncmp(res_num,domain_ptr->end_residue_number,5) <= 0)
		under_end = TRUE;
	      else
		under_end = FALSE;

	      /* If residue is within the range of this domain, then
		 store the domain number */
	      if (over_start == TRUE && under_end == TRUE)
		{
		  /* Store 1 or 2, according to whether this domain is
		     the first or second in the user's list */
		  if (domain_ptr->domain_number == domain1)
		    chain_domain = 1;
		  else
		    chain_domain = 2;
		}
	    }

	  /* Go to the next domain record */
	  domain_ptr = domain_ptr->next_domain_ptr;
	}
    }

  /* Return the wanted flag */
  return(chain_domain);
}
/***********************************************************************

read_pdb - Read through pdb file and store all the residue and atom data

**********************************************************************/	 

void read_pdb(char pdb_name[FILENAME_LEN],int *natoms,int *nresidues,
	      char chain1,char chain2,int by_domain,int domain1)
{
  char line[LINE_LEN +1];
  char chain, last_chain;
  char last_res_name[4], res_name[4];
  char last_res_num[6], res_num[6];

  int chain_domain;
  int done, residue_wanted;
  
  struct atom *atom_ptr;
  struct residue *residue_ptr;

  FILE *fil_pdb;

  /* Initialise variables */
  first_atom_ptr = NULL;         
  last_atom_ptr = NULL;         
  first_residue_ptr = NULL;
  last_residue_ptr = NULL;
  *natoms = 0;
  *nresidues = 0;
  last_chain = '\0';
  last_res_num[0] = '\0';
  last_res_name[0] = '\0';
  chain = ' ';
  res_num[0] = '\0';
  res_name[0] = '\0';

  /* Open the PDB file */
  printf("\n\n  Opening PDB file [%s] ...",pdb_name);
  if ((fil_pdb = fopen(pdb_name,"r")) == NULL)
    {
      printf("\n*** Unable to open your PDB file [%s]\n",pdb_name);
      exit(1);
    }

  /* Prepare to start reading in the data from the PDB file */
  printf("\n");
  printf("  Reading through PDB file ...\n");
  printf("\n");
  done = FALSE;
  residue_wanted = FALSE;

  /* Loop while reading through the PDB file */
  while (fgets(line,LINE_LEN,fil_pdb) != NULL && done == FALSE)
    { 
      /* Check if ATOM or HETATM record */
      if (!strncmp(line,"ATOM  ",6) || !strncmp(line,"HETATM",6))
        {               
	  /* Extract the residue name, number and chain-id */
	  strncpy(res_name,line+17,3);
	  res_name[3] = '\0';
	  strncpy(res_num,line+22,5);
	  res_num[5] = '\0';
	  chain = line[21];

	  /* Check whether this is a new residue */
	  if (chain != last_chain || strncmp(res_num,last_res_num,5) ||
	      strncmp(res_name,last_res_name,3))
	    {
	      /* Determine whether this residue is wanted */
	      if (!strncmp(res_name,"HOH",3))
		{
		  chain_domain = 0;
		  residue_wanted = TRUE;
		}
	      else
		{
		  /* Check whether residue belongs to one of the chains
		     or domains in question */
		  chain_domain
		    = check_residue(res_num,chain,chain1,chain2,by_domain,
				    domain1);
		  if (chain_domain != 0)
		    residue_wanted = TRUE;
		  else
		    residue_wanted = FALSE;
		}

	      /* If this residue is wanted, then create a record for it */
	      if (residue_wanted == TRUE)
		{
		  /* Allocate memory to store this residue's details */  
		  residue_ptr
		    = (struct residue*)malloc(sizeof(struct residue));
		  if (residue_ptr == NULL)
		    {
		      printf("*** Can't allocate memory for struct");
		      printf(" residue\n");
		      exit (1);
		    }

		  /* If this is first residue stored, then
		     update pointer to head of linked list */               
		  if (first_residue_ptr == NULL)
		    first_residue_ptr = residue_ptr;

		  /* Otherwise update previous residue's link so it points
		     to this one*/
		  else
		    last_residue_ptr->next_residue_ptr = residue_ptr;

		  /* Store details from record read in */
		  strncpy(residue_ptr->res_name,res_name,3);
		  residue_ptr->res_name[3] = '\0';
		  strncpy(residue_ptr->res_num,res_num,5);
		  residue_ptr->res_num[5] = '\0';
		  residue_ptr->chain = chain;

		  /* Store chain/domain to which the residue belongs */
		  residue_ptr->chain_domain = chain_domain;
		  residue_ptr->interacting = FALSE;

		  /* Store pointer to this residue's first atom */
		  residue_ptr->first_atom_ptr = NULL;
		  residue_ptr->num_atoms = 0;

		  /* Set next residue pointer to null */
		  residue_ptr->next_residue_ptr = NULL;

		  /* Save current residue's pointer as last residue's
		     pointer */
		  last_residue_ptr = residue_ptr;

		  /* Increment count of residues */
		  (*nresidues)++;
		}

	      /* Store the current residue number, name and chain ID */
	      strncpy(last_res_num,res_num,5);
	      last_res_num[5] = '\0';
	      strncpy(last_res_name,res_name,5);
	      last_res_name[3] = '\0';
	      last_chain = chain;
	    }

	  /* If current residue is wanted, then store this atom */
	  if (residue_wanted == TRUE)
	    {
	      /* Allocate memory to store this atom's details */  
	      atom_ptr = (struct atom*)malloc(sizeof(struct atom));
	      if (atom_ptr == NULL)
		{
		  printf("*** Can't allocate memory for struct");
		  printf(" atom\n");
		  exit (1);
		}

	      /* If this is first atom stored, then update pointer
		 to head of linked list */               
	      if (first_atom_ptr == NULL)
		first_atom_ptr = atom_ptr;

	      /* Otherwise update previous atom's link so it points to
		 this one*/
	      else
		last_atom_ptr->next_atom_ptr = atom_ptr;

	      /* Store details from records read in */
	      strncpy(atom_ptr->label,line,6);
	      atom_ptr->label[6] = '\0';
	      sscanf(line+6,"%5d",&(atom_ptr->atom_number));
	      strncpy(atom_ptr->atom_name,line+12,4);
	      atom_ptr->atom_name[4]='\0';
	      sscanf(line+30,"%f%f%f ",&atom_ptr->x,&atom_ptr->y,&atom_ptr->z);
	      strncpy(atom_ptr->occupancy,line+54,6);
	      atom_ptr->occupancy[6] = '\0';
	      strncpy(atom_ptr->bvalue,line+60,6);
	      atom_ptr->bvalue[6] = '\0';

	      /* Store pointer to current residue */
	      atom_ptr->residue_ptr = residue_ptr;

	      /* Set next atom pointer to null */
	      atom_ptr->next_atom_ptr = NULL;

	      /* Save current atom's pointer as last atom pointer */
	      last_atom_ptr = atom_ptr;

	      /* Increment count of atoms belonging to this residue */
	      residue_ptr->num_atoms++;

	      /* If this is the first atom of this residue, store its
		 pointer */
	      if (residue_ptr->first_atom_ptr == NULL)
		residue_ptr->first_atom_ptr = atom_ptr;
	    }

	  /* Increment count of atoms */
	  (*natoms)++;
	}
     
      /* If this is a MODEL or ENDMDL record, and already have read in
         at least one atom, then want to end here */
      else if (!strncmp(line,"MODEL ",6) || !strncmp(line,"ENDMDL",6))
        {
	  /* Check that have at least one atom and residue */
	  if (*natoms > 0 && *nresidues > 0)
	    done = TRUE;
	}
    }

  /* Close the PDB file */
  fclose(fil_pdb);
}  
/***********************************************************************

get_hbplus_info  -  Extract the atom details from the interaction just
                    read in from the .hhb or .nnb file

***********************************************************************/

void get_hbplus_info(char line[LINE_LEN + 1],char atom_name1[5],
		    char atom_name2[5],char *chain1,char *chain2,
		    char res_name1[4],char res_name2[4],
		    char res_num1[6],char res_num2[6],float *bond_length)
{
  char bond_lenstr[5];
  int ipos, nonzero;

  /* Atom name */
  strncpy(atom_name1,line+19,4);
  atom_name1[4] = '\0';
  strncpy(atom_name2,line+39,4);
  atom_name2[4] = '\0';
		
  /* Chain-id */
  *chain1 = line[10];
  *chain2 = line[30];
  if ((*chain1) == '-')
    *chain1 = ' ';
  if ((*chain2) == '-')
    *chain2 = ' ';
	  
  /* Residue details */
  strncpy(res_num1,line+11,5);
  res_num1[5] = '\0';
  strncpy(res_num2,line+31,5);
  res_num2[5] = '\0';
  strncpy(res_name1,line+16,3);
  res_name1[3] = '\0';
  strncpy(res_name2,line+36,3);
  res_name2[3] = '\0';

  /* Bond length */
  strncpy(bond_lenstr,line+45,4);
  bond_lenstr[4] = '\0';
  *bond_length = atof(bond_lenstr);
    
  /* For the residue numbers, may need to replace any leading
     zeros by spaces */

  /* First residue */
  nonzero = FALSE;
  for (ipos = 0; ipos < 3 && nonzero == FALSE; ipos ++)
    {
      if (res_num1[ipos] == '0')
	res_num1[ipos] = ' ';
      else
	nonzero = TRUE;
    }

  /* Replace hyphen in insertion code with a space */
  if (res_num1[4] == '-')
    res_num1[4] = ' ';
		
  /* Repeat for second residue */
  nonzero = FALSE;
  for (ipos = 0; ipos < 3 && nonzero == FALSE; ipos ++)
    {
      if (res_num2[ipos] == '0')
	res_num2[ipos] = ' ';
      else
	nonzero = TRUE;
    }

  /* Replace hyphen in insertion code with a space */
  if (res_num2[4] == '-')
    res_num2[4] = ' ';
}
/***********************************************************************

read_hbplus_file  -  Read in the required H-bond and nonbonded contacts
                     from the appropriate HBPLUS output file
                     
***********************************************************************/

void read_hbplus_file(char file_name[FILENAME_LEN],int type)
{
  char line[LINE_LEN + 1];
  char atom_name1[5], atom_name2[5], chain1, chain2, res_name1[4],
  res_name2[4], res_num1[6], res_num2[6];
  
  int have_file, wanted;
  static int first = TRUE;

  float bond_length;

  struct hhb_info *hhb_info_ptr;
  struct residue *residue_ptr, *residue1_ptr, *residue2_ptr;

  FILE *hbplus_file;

  /* Initialise variables */
  have_file = TRUE;

  /* These are only initialised if this function is being called
     for the first time */
  if(first == TRUE)
    {
      first_hhb_info_ptr = NULL;
      last_hhb_info_ptr = NULL;
      first = FALSE;
    }

  /* Open the HBPLUS input file */
  if ((hbplus_file = fopen(file_name,"r")) == NULL)
    {
      printf("\n*** Unable to open %s\n",file_name);
      have_file = FALSE;
    }

  /* If input file exists, read in the interactions */
  if (have_file == TRUE)
    {
      /* If the function is being called for the first time i.e. 
	 it is reading in H-bonds from the .hhb filename */
      if(type == HBONDS)
	printf("Reading in hydrogen bonds from file %s ....\n",file_name);

      /* Else, it is reading in non-bonded contacts from the
	 .nnb filename */
      else
	printf(".... and non-bonded contacts from file %s\n\n",file_name);

      /* Loop while reading through the file */
      while (fgets(line,LINE_LEN,hbplus_file) != NULL)
	{
	  /* Extract the relevant information from the line just
	     read in */
	  get_hbplus_info(line,atom_name1,atom_name2,&chain1, 
			  &chain2,res_name1,res_name2,
			  res_num1,res_num2,&bond_length);	 
    
	  /* Check whether this interaction is wanted */

	  /* Get pointer to the first residue */
	  residue_ptr = first_residue_ptr;
	  residue1_ptr = NULL;
	  residue2_ptr = NULL;

	  /* Loop through all the residues, checking whether current
	     interaction is between currently stored residues */
	  while (residue_ptr != NULL &&
		 (residue1_ptr == NULL || residue2_ptr == NULL))
	    {
	      /* Check whether current residue corresponds to the first one
		 in the current interaction */
	      if (!strncmp(res_name1,residue_ptr->res_name,3) &&
		  !strncmp(res_num1,residue_ptr->res_num,5) &&
		  chain1 == residue_ptr->chain)
		residue1_ptr = residue_ptr;
      
	      /* Check whether current residue corresponds to the second one
		 in the current interaction */
	      if (!strncmp(res_name2,residue_ptr->res_name,3) &&
		  !strncmp(res_num2,residue_ptr->res_num,5) &&
		  chain2 == residue_ptr->chain)
		residue2_ptr = residue_ptr;
      
	      /* Get next residue in the list */
	      residue_ptr = residue_ptr->next_residue_ptr;
	    }

	  /* If residues are from different sides of the interface,
	     or are to a water, then want to store the interaction */
	  wanted = FALSE;
	  if (residue1_ptr != NULL && residue2_ptr != NULL)
	    {
	      if (residue1_ptr->chain_domain != residue2_ptr->chain_domain)
		wanted = TRUE;

	      /* For non-bonded contacts, don't want waters included */
	      if (type == CONTACTS && (residue1_ptr->chain_domain == 0 ||
				       residue2_ptr->chain_domain == 0))
		wanted = FALSE;
	    }

	  /* If interaction wanted, store in linked list */
	  if (wanted == TRUE)
	    {
	      /* If interaction doesn't involve waters, then mark both
		 residues as interacting ones */
	      if (residue1_ptr->chain_domain > 0 &&
		  residue2_ptr->chain_domain > 0)
		{
		  /* Set flags indicating residues are interacting with
		     the other side of the interface */
		  residue1_ptr->interacting = TRUE;
		  residue2_ptr->interacting = TRUE;
		}

	      /* Allocate memory for this interaction */  
	      hhb_info_ptr=(struct hhb_info*)
		malloc(sizeof(struct hhb_info));
	      if (hhb_info_ptr == NULL)
		{
		  printf("*** Can't allocate memory for struct");
		  printf(" hhb_info\n");
		  exit (1);
		}

	      /* If this is first interaction stored, then update
		 pointer to head of linked list */               
	      if (first_hhb_info_ptr==NULL)
		first_hhb_info_ptr=hhb_info_ptr;

	      /* Otherwise update previous interaction so it points to
		 this one*/
	      else
		last_hhb_info_ptr->next_hhb_info_ptr=hhb_info_ptr;

	      /* Store interaction type */
	      hhb_info_ptr->type = type;

	      /* First atom's details */
	      strncpy(hhb_info_ptr->atom_name1,atom_name1,4);
	      hhb_info_ptr->atom_name1[4] = '\0';
	      strncpy(hhb_info_ptr->res_name1,res_name1,3);
	      hhb_info_ptr->res_name1[3] = '\0';
	      strncpy(hhb_info_ptr->res_num1,res_num1,5);
	      hhb_info_ptr->res_num1[5] = '\0';
	      hhb_info_ptr->chain1 = chain1;

	      /* Second atom's details */
	      strncpy(hhb_info_ptr->atom_name2,atom_name2,4);
	      hhb_info_ptr->atom_name2[4] = '\0';
	      strncpy(hhb_info_ptr->res_name2,res_name2,3);
	      hhb_info_ptr->res_name2[3] = '\0';
	      strncpy(hhb_info_ptr->res_num2,res_num2,5);
	      hhb_info_ptr->res_num2[5] = '\0';
	      hhb_info_ptr->chain2 = chain2;

	      /* Domain/chains to which residues belong */
	      hhb_info_ptr->chain_domain1 = residue1_ptr->chain_domain;
	      hhb_info_ptr->chain_domain2 = residue2_ptr->chain_domain;

	      /* Store residue pointers, too */
	      hhb_info_ptr->residue1_ptr = residue1_ptr;
	      hhb_info_ptr->residue2_ptr = residue2_ptr;

	      /* Distance between atoms */
	      hhb_info_ptr->bond_length = bond_length;

	      /* Set next pointer to null */
	      hhb_info_ptr->next_hhb_info_ptr = NULL;

	      /* Save the current interaction's pointer */
	      last_hhb_info_ptr = hhb_info_ptr;
	    }
	}
    }

  /* close input file */
  fclose(hbplus_file);
}
/**********************************************************************

check_waters - Check waters to keep any interacting with both sides of
               the interface

**********************************************************************/

void check_waters(void)
{
  int chain_domain1, chain_domain2, want_water;

  struct residue *other_residue_ptr, *prev_residue_ptr, *residue_ptr;
  struct hhb_info *hhb_info_ptr, *prev_hhb_info_ptr;

  /* Set residue pointer to the first residue */
  residue_ptr = first_residue_ptr;
  prev_residue_ptr = NULL;

  /* Loop through all the residues */
  while (residue_ptr != NULL)
    { 
      /* Proceed only if this is a water */
      if (residue_ptr->chain_domain == 0)
	{
	  /* Initialise variables */
	  chain_domain1 = FALSE;
	  chain_domain2 = FALSE;

	  /* Set pointer to the first of the interaction records */
	  hhb_info_ptr = first_hhb_info_ptr;
	  want_water = FALSE;

	  /* Loop through the interactions */
	  while (hhb_info_ptr != NULL && want_water == FALSE)
	    {
	      /* Check whether this interaction involves the residue
		 of interest */
	      other_residue_ptr = NULL;
	      if (hhb_info_ptr->residue1_ptr == residue_ptr)
		other_residue_ptr = hhb_info_ptr->residue2_ptr;
	      else if (hhb_info_ptr->residue2_ptr == residue_ptr)
		other_residue_ptr = hhb_info_ptr->residue1_ptr;

	      /* If it does, then store chain/domain to which other
		 atom belongs */
	      if (other_residue_ptr != NULL)
		{
		  /* Set appropriate flag */
		  if (other_residue_ptr->chain_domain == 1)
		    chain_domain1 = TRUE;
		  else if (other_residue_ptr->chain_domain == 2)
		    chain_domain2 = TRUE;

		  /* If water interacts with residues on both sides of
		     the interface, then want this water */
		  if (chain_domain1 == TRUE && chain_domain2 == TRUE)
		    want_water = TRUE;
		}

	      /* Get the next interaction */
	      hhb_info_ptr = hhb_info_ptr->next_hhb_info_ptr;
	    }

	  /* If water is wanted, then mark it as interacting, and mark
	     all residues interacting with it as interacting, also */
	  if (want_water == TRUE)
	    {
	      /* Mark the water as interacting */
	      residue_ptr->interacting = TRUE;

	      /* Get pointer to the first of the interaction records */
	      hhb_info_ptr = first_hhb_info_ptr;

	      /* Loop through the interactions */
	      while (hhb_info_ptr != NULL)
		{
		  /* Check whether this interaction involves the current
		     water */
		  other_residue_ptr = NULL;
		  if (hhb_info_ptr->residue1_ptr == residue_ptr)
		    other_residue_ptr = hhb_info_ptr->residue2_ptr;
		  else if (hhb_info_ptr->residue2_ptr == residue_ptr)
		    other_residue_ptr = hhb_info_ptr->residue1_ptr;

		  /* If have a residue interacting with the water,
		     then mark it as being of interest */
		  if (other_residue_ptr != NULL)
		    {
		      /* Set appropriate flag */
		      other_residue_ptr->interacting = TRUE;
		    }

		  /* Get the next interaction */
		  hhb_info_ptr = hhb_info_ptr->next_hhb_info_ptr;
		}
	    }

	  /* Otherwise, if this water is not wanted, then delete it and
	     all its interactions */
	  else
	    {
	      /* If this is the first residue in the list, readjust
		 the pointer for the head of the list */
	      if (prev_residue_ptr == NULL)
		first_residue_ptr = residue_ptr->next_residue_ptr;

	      /* Otherwise, adjust previous residue's pointer to point
		 to the next in the list */
	      else
		prev_residue_ptr->next_residue_ptr
		  = residue_ptr->next_residue_ptr;

	      /* Initialise variables for deleting all the interactions
		 involving the deleted residue */
	      prev_hhb_info_ptr = NULL;

	      /* Set pointer to the first interaction */
	      hhb_info_ptr = first_hhb_info_ptr;

	      /* Loop through the interactions */
	      while (hhb_info_ptr != NULL && want_water == FALSE)
		{
		  /* Check whether this interaction involves the residue
		     of interest */
		  if (hhb_info_ptr->residue1_ptr == residue_ptr ||
		      hhb_info_ptr->residue2_ptr == residue_ptr)
		    {
		      /* Delete this interaction */

		      /* If this is the first interaction in the list,
			 readjust the pointer for the head of the list */
		      if (prev_hhb_info_ptr == NULL)
			first_hhb_info_ptr = hhb_info_ptr->next_hhb_info_ptr;

		      /* Otherwise, adjust previous interaction's pointer
			 to point to the next in the list */
		      else
			prev_hhb_info_ptr->next_hhb_info_ptr
			  = hhb_info_ptr->next_hhb_info_ptr;
		    }

		  /* If keeping the interaction, save it */
		  else
		    prev_hhb_info_ptr = hhb_info_ptr;

		  /* Get the next interaction */
		  hhb_info_ptr = hhb_info_ptr->next_hhb_info_ptr;
		}

	      /* Make the current residue the previous one, as the
		 true current one has now been deleted */
	      residue_ptr = prev_residue_ptr;
	    }
	}

      /* Save the current residue */
      prev_residue_ptr = residue_ptr;

      /* Go to next residue */
      residue_ptr = residue_ptr->next_residue_ptr;
    }
}
/**********************************************************************

output_hbplus_info - Output all the stored H-bond and non-bonded contacts
                     information

**********************************************************************/

void output_hbplus_info(char file_name[FILENAME_LEN],int type)
{
  struct hhb_info *hhb_info_ptr;

  FILE *file_ptr;

  /* Open output file */
  if((file_ptr = fopen(file_name,"w"))==NULL)
    {
      printf("*** ERROR: Cannot open output file %s\n",file_name);
      exit(1);
    }                

  /* Write out the header information to the file */
  if (type == HBONDS)
    {
      fprintf(file_ptr,"ligplot.hhb output:\n");
      fprintf(file_ptr,"\n");
      fprintf(file_ptr,"   Donor                  Acceptor     Distance\n"); 
    }
  else
    {
      fprintf(file_ptr,"ligplot.nnb output:\n");
      fprintf(file_ptr,"\n");
      fprintf(file_ptr,"   Atom 1               Atom 2        Distance\n");
    }
 
  /* Start at first interaction */
  hhb_info_ptr = first_hhb_info_ptr;

  /* Loop through interactions */
  while (hhb_info_ptr != NULL)
    {
      /* Check that the interaction is of the required type */
      if (hhb_info_ptr->type == type)
	{
	  /* Write out this interaction */
	  fprintf(file_ptr,"%s %c %s %s     %s %c %s %s    %1.2f\n",
		  hhb_info_ptr->res_name1,
		  hhb_info_ptr->chain1,
		  hhb_info_ptr->res_num1,
		  hhb_info_ptr->atom_name1,
		  hhb_info_ptr->res_name2,
		  hhb_info_ptr->chain2,
		  hhb_info_ptr->res_num2,
		  hhb_info_ptr->atom_name2,
		  hhb_info_ptr->bond_length);
	}

      /* Go to the next interaction */
      hhb_info_ptr = hhb_info_ptr->next_hhb_info_ptr;
    }

  /* Close the file */
  fclose(file_ptr);
}
/**********************************************************************

pdb_out - Write out all interacting residues (hydrogen bonded and
          non-bonded contacts) in PDB format into an output file
          "hblinks.pdb"

**********************************************************************/

void pdb_out(char file_name[FILENAME_LEN],char root_name[FILENAME_LEN],
	     char chain1,char chain2,int by_domain,int domain1,int domain2)
{
  int chain_domain, iatom, loop, natoms;
  int natoms_out, nresid_out;
  int out_order[3] = { 1, 2, 0 };

  struct residue *residue_ptr;
  struct atom *atom_ptr;

  FILE *file_ptr; 

  /* Initialise variables for number of atoms and residues involved 
     in the interactions */
  natoms_out = 0;
  nresid_out = 0;

  /* open output file */
  if((file_ptr= fopen(file_name, "w"))==NULL)
    {
      printf("*** ERROR: Cannot open output file %s \n",file_name);
      exit(1);
    }

  /* Write out the title to appear on the final plot */
  fprintf(file_ptr,"Title: %s: ",root_name);
  if (by_domain == FALSE)
    fprintf(file_ptr,"chains %c and %c\n",chain1,chain2);
  else
    fprintf(file_ptr,"domains %d and %d\n",domain1,domain2);

  /* Loop over the three types of residues to be written out: 1) those
     belonging to the first chain/domain, 2) those of the second chain/domain,
     and 3) any waters spanning the interface */
  for (loop = 0; loop < 3; loop++)
    {
      /* Get the chain/domain to be written out */
      chain_domain = out_order[loop];

      /* Write out the appropriate header record */
      if (chain_domain == 0)
	fprintf(file_ptr,"WATERS\n");
      else
	fprintf(file_ptr,"SURFACE %d\n",chain_domain);

      /* Set residue pointer to the first residue */
      residue_ptr = first_residue_ptr;

      /* Loop through all residues to write out those belonging to the
         current chain/domain */
      while (residue_ptr != NULL)
	{ 
	  /* If this residue belongs to the appropriate chain/domain, and
	     is wanted, then write out */
	  if (residue_ptr->chain_domain == chain_domain &&
	      residue_ptr->interacting == TRUE)
	    {
	      /* set atom pointer to the first atom on the stack */
	      atom_ptr = residue_ptr->first_atom_ptr;
	      natoms = residue_ptr->num_atoms;

	      /* Loop through all this residue's atoms */
	      for (iatom = 0; iatom < natoms && atom_ptr != NULL; iatom++)
		{
		  /* Increment count of atoms written out */
		  natoms_out++;
  
		  /* Write this atom record */
		  fprintf(file_ptr,"%s%5d %s %s %c%s   %8.3f%8.3f%8.3f",
			  atom_ptr->label, 
			  atom_ptr->atom_number,
			  atom_ptr->atom_name,
			  residue_ptr->res_name,
			  residue_ptr->chain,
			  residue_ptr->res_num,
			  atom_ptr->x,atom_ptr->y,
			  atom_ptr->z);
		  fprintf(file_ptr,"%s%s\n",
			  atom_ptr->occupancy,atom_ptr->bvalue);

		  /* Get residue's next atom */
		  atom_ptr = atom_ptr->next_atom_ptr; 
		}

	      /* Increment count of residues written out */
	      nresid_out++;
	    }

	  /* Get next residue */
	  residue_ptr = residue_ptr->next_residue_ptr;
	}
    }

  /* Close the file */
  fclose(file_ptr);

  /* Show numbers of records written out */
  printf("Number of residues written out: %6d,  Atoms: %6d\n",nresid_out,
	 natoms_out);

}
/***********************************************************************

                             M   A   I   N

***********************************************************************/

int main(int argc,char *argv[])
{
  char pdb_name[FILENAME_LEN];
  char dom_name[FILENAME_LEN], full_dom_name[FILENAME_LEN];
  char hhb_name[FILENAME_LEN], nnb_name[FILENAME_LEN];
  char root_name[FILENAME_LEN], full_root_name[FILENAME_LEN];
  char chain1, chain2;

  int natoms, nresidues;
  int by_domain;
  int domain1, domain2;

  /* Get the PDB file name from the command-line arguments*/
  get_command_arguments(argv,argc - 1,pdb_name,&chain1,&chain2,&by_domain,
			&domain1,&domain2);

  /* Get all the associated filenames */
  get_filename(pdb_name,dom_name,".dom",root_name,full_root_name);
  get_filename(pdb_name,hhb_name,".hhb",root_name,full_root_name);
  get_filename(pdb_name,nnb_name,".nnb",root_name,full_root_name);

  /* Get full name of domains .dom file if it is in the same directory
     as the PDB file */
  strcpy(full_dom_name,full_root_name);
  strcat(full_dom_name,".dom");

  /* Read in the .dom file to get the domain information */
  if (by_domain == TRUE)
    get_domains(dom_name,full_dom_name,domain1,domain2);

  /* Read through pdb file, storing all residues */
  read_pdb(pdb_name,&natoms,&nresidues,chain1,chain2,by_domain,domain1);

  /* Read in the required H-bonds from the .hhb file */
  read_hbplus_file(hhb_name,HBONDS);

  /* Read in the required non-bonded interactions from the .nnb file */
  read_hbplus_file(nnb_name,CONTACTS);

  /* Checks HETATMs from from HBPLUS linked list to keep any involved 
     with both chains*/
  check_waters();

  /* Write out all the retained H-bonds to the output .hhb file */
  strcpy(hhb_name,OUTFILE_2);
  output_hbplus_info(hhb_name,HBONDS);

  /* Write out all the retained non-bonded contacts to the output .nnb file */
  strcpy(nnb_name,OUTFILE_3);
  output_hbplus_info(nnb_name,CONTACTS);

  /* Write out interacting residues to PDB output file */
  strcpy(pdb_name,OUTFILE_1);
  pdb_out(pdb_name,root_name,chain1,chain2,by_domain,domain1,domain2);

  /* Finish */
  return(0);
}
